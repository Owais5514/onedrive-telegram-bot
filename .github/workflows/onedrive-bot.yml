name: OneDrive Telegram Bot

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'start_bot'
        type: choice
        options:
          - start_bot
          - index_files
      duration:
        description: 'Bot runtime duration (in minutes, 0 for indefinite)'
        required: false
        default: '60'
        type: string

jobs:
  run-bot:
    runs-on: ubuntu-latest
    timeout-minutes: 720  # 12 hours max
    permissions:
      contents: write  # Allow pushing commits and branches
      actions: read    # Allow reading workflow context
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history for branch operations
        token: ${{ secrets.GITHUB_TOKEN }}  # Ensure push permissions

    - name: Fetch index branch (if exists)
      run: |
        # Try to fetch the index-data branch if it exists
        if git ls-remote --heads origin index-data | grep -q index-data; then
          echo "📥 Fetching existing index-data branch..."
          git fetch origin index-data:index-data
          echo "✅ Index branch fetched"
        else
          echo "ℹ️ No index-data branch found, will create if needed"
        fi
        
        # Try to fetch the feedback-logs branch if it exists
        if git ls-remote --heads origin feedback-logs | grep -q feedback-logs; then
          echo "📥 Fetching existing feedback-logs branch..."
          git fetch origin feedback-logs:feedback-logs
          echo "✅ Feedback branch fetched"
        else
          echo "ℹ️ No feedback-logs branch found, will create if needed"
        fi

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Create .env file
      run: |
        cat > .env << EOF
        # Telegram Bot
        TELEGRAM_BOT_TOKEN=${{ secrets.TELEGRAM_BOT_TOKEN }}

        # Azure App Registration
        AZURE_CLIENT_ID=${{ secrets.AZURE_CLIENT_ID }}
        AZURE_CLIENT_SECRET=${{ secrets.AZURE_CLIENT_SECRET }}
        AZURE_TENANT_ID=${{ secrets.AZURE_TENANT_ID }}

        # Target OneDrive User (email or user ID to access their OneDrive)
        TARGET_USER_ID=${{ secrets.TARGET_USER_ID }}

        # Admin User ID (Telegram user ID for admin commands)
        ADMIN_USER_ID=${{ secrets.ADMIN_USER_ID }}

        # Optional: For debugging
        DEBUG=True
        EOF

    - name: Run Bot Action
      run: |
        case "${{ github.event.inputs.action }}" in
          "start_bot")
            echo "🤖 Starting OneDrive Telegram Bot..."
            echo "📊 Checking for existing index files..."
            if [ -f "file_index.json" ]; then
              echo "✅ Found existing index file ($(stat -c%s file_index.json) bytes)"
            else
              echo "ℹ️ No existing index file found, will build new index"
            fi
            
            if [ "${{ github.event.inputs.duration }}" != "0" ]; then
              echo "⏰ Bot will run for ${{ github.event.inputs.duration }} minutes"
              # Run with timeout and proper signal handling
              timeout --signal=TERM --kill-after=30s "${{ github.event.inputs.duration }}m" python main.py || {
                exit_code=$?
                if [ $exit_code -eq 124 ]; then
                  echo "⏰ Bot stopped after ${{ github.event.inputs.duration }} minutes (timeout)"
                elif [ $exit_code -eq 137 ]; then
                  echo "🛑 Bot was forcefully terminated"
                else
                  echo "❌ Bot exited with code $exit_code"
                fi
              }
            else
              echo "🔄 Bot will run indefinitely until manually stopped"
              python main.py
            fi
            ;;
          "index_files")
            echo "📁 Running file indexer..."
            python indexer.py --force
            echo "📊 Index build completed"
            if [ -f "file_index.json" ]; then
              echo "✅ Index file created ($(stat -c%s file_index.json) bytes)"
            fi
            ;;
          *)
            echo "❌ Unknown action: ${{ github.event.inputs.action }}"
            exit 1
            ;;
        esac

    - name: Check and Commit Index Files
      if: always()
      run: |
        echo "📊 Checking for updated index files..."
        
        # Check if index files exist and have been modified
        if [ -f "file_index.json" ] && [ -f "index_timestamp.txt" ]; then
          echo "✅ Index files found"
          
          # Get index file info
          INDEX_SIZE=$(stat -c%s file_index.json)
          TIMESTAMP_CONTENT=$(cat index_timestamp.txt)
          TIMESTAMP_DATE=$(python3 -c "import datetime; print(datetime.datetime.fromtimestamp(float('$TIMESTAMP_CONTENT')).strftime('%Y-%m-%d %H:%M:%S UTC'))")
          
          echo "📄 Index file size: $INDEX_SIZE bytes"
          echo "🕐 Index timestamp: $TIMESTAMP_DATE"
          
          # The Git integration in the indexer should have already committed these
          # Let's verify if the index-data branch was created/updated
          if git show-ref --verify --quiet refs/heads/index-data; then
            echo "✅ Index-data branch exists"
            
            # Check if it was recently updated
            LAST_COMMIT_DATE=$(git log -1 --format="%ci" index-data)
            echo "📅 Last commit on index-data branch: $LAST_COMMIT_DATE"
            
            # Ensure the index-data branch is pushed
            echo "📤 Ensuring index-data branch is up to date on remote..."
            git push origin index-data --force-with-lease || {
              echo "🔄 Force pushing index-data branch..."
              git push origin index-data --force
            }
            echo "✅ Index-data branch synchronized with remote"
          else
            echo "⚠️ Index-data branch not found, Git integration may have failed"
          fi
        else
          echo "ℹ️ No index files found to commit"
        fi

    - name: Check and Commit Feedback Files  
      if: always()
      run: |
        echo "📝 Checking for feedback files..."
        
        # Check if feedback file exists and has new content
        if [ -f "feedback_log.txt" ]; then
          echo "✅ Feedback log file found"
          
          # Get feedback file info
          FEEDBACK_SIZE=$(stat -c%s feedback_log.txt)
          echo "📄 Feedback file size: $FEEDBACK_SIZE bytes"
          
          # Check if file is not empty
          if [ $FEEDBACK_SIZE -gt 0 ]; then
            echo "📝 Feedback file contains data"
            
            # The Git integration in the bot should have already committed feedback in real-time
            # Let's verify if there are any uncommitted feedback changes
            if git diff --quiet feedback_log.txt 2>/dev/null; then
              echo "ℹ️ No uncommitted feedback changes (already committed by bot)"
            else
              echo "⚠️ Found uncommitted feedback changes, committing now..."
              
              # Configure git for backup commit
              git config user.name "GitHub Actions Feedback Bot"
              git config user.email "feedback-bot@onedrive-telegram-bot.local" 
              git config commit.gpgsign false
              
              # Commit any remaining feedback
              git add -f feedback_log.txt
              TIMESTAMP=$(date -u '+%Y-%m-%d %H:%M:%S UTC')
              git commit -m "Backup commit: feedback log - $TIMESTAMP" || echo "No changes to commit"
              
              # Push to main branch
              git push origin main || echo "Push failed, may be up to date"
            fi
            
            # Also check if feedback-logs branch was created/updated
            if git show-ref --verify --quiet refs/heads/feedback-logs; then
              echo "✅ Feedback-logs branch exists"
              
              # Ensure the feedback-logs branch is pushed
              echo "📤 Ensuring feedback-logs branch is up to date on remote..."
              git push origin feedback-logs --force-with-lease || {
                echo "🔄 Force pushing feedback-logs branch..."
                git push origin feedback-logs --force
              }
              echo "✅ Feedback-logs branch synchronized with remote"
            else
              echo "ℹ️ No dedicated feedback-logs branch (feedback committed to main branch)"
            fi
          else
            echo "ℹ️ Feedback file is empty"
          fi
        else
          echo "ℹ️ No feedback file found"
        fi

    - name: Configure Git for Log Commits
      if: always()
      run: |
        # Configure git identity for automated commits
        git config --global user.name "GitHub Actions Bot"
        git config --global user.email "actions@github.com"
        
        # Set environment variables for commit operations
        export GIT_AUTHOR_NAME="GitHub Actions Bot"
        export GIT_AUTHOR_EMAIL="actions@github.com"
        export GIT_COMMITTER_NAME="GitHub Actions Bot"
        export GIT_COMMITTER_EMAIL="actions@github.com"

    - name: Commit and Push logs (if any)
      if: always()
      run: |
        # Check if any log files exist
        if ls *.log *.json 2>/dev/null || [ -d "logs" ]; then
          echo "📝 Log files found, committing to logs branch..."
          
          # Get the current commit hash for reference
          MAIN_COMMIT=$(git rev-parse HEAD)
          echo "📍 Main branch commit: $MAIN_COMMIT"
          
          # Ensure we're on main branch
          git checkout main 2>/dev/null || git checkout -b main
          
          # Force add all log files (bypassing .gitignore)
          git add -f *.log *.json logs/ 2>/dev/null || true
          
          # Check if there are any changes to commit
          if git diff --cached --quiet; then
            echo "ℹ️ No log changes to commit"
          else
            # Create commit message with timestamp and run info
            TIMESTAMP=$(date -u '+%Y-%m-%d %H:%M:%S UTC')
            COMMIT_MSG="Bot logs from GitHub Actions run ${{ github.run_number }} - $TIMESTAMP"
            
            # Fetch remote logs branch if it exists
            git fetch origin logs:logs 2>/dev/null || true
            
            # Get or create logs branch
            if git show-ref --verify --quiet refs/heads/logs; then
              echo "📋 Using existing logs branch"
              LOGS_EXISTS=true
            else
              echo "🆕 Creating new logs branch"
              LOGS_EXISTS=false
            fi
            
            # Commit to logs branch using commit-tree (preserves main branch checkout)
            TREE_HASH=$(git write-tree)
            if [ "$LOGS_EXISTS" = "true" ]; then
              PARENT_COMMIT=$(git rev-parse logs)
              COMMIT_HASH=$(git commit-tree $TREE_HASH -p $PARENT_COMMIT -m "$COMMIT_MSG")
            else
              COMMIT_HASH=$(git commit-tree $TREE_HASH -m "$COMMIT_MSG (initial logs commit)")
            fi
            
            # Update logs branch reference
            git update-ref refs/heads/logs $COMMIT_HASH
            
            echo "✅ Logs committed to logs branch: $COMMIT_HASH"
            
            # Push logs branch to remote
            echo "📤 Pushing logs branch to remote..."
            if git push origin logs 2>/dev/null; then
              echo "✅ Logs successfully pushed to remote repository"
            else
              echo "🔄 Force pushing logs branch..."
              git push origin logs --force
              echo "✅ Logs force-pushed to remote repository"
            fi
          fi
        else
          echo "ℹ️ No log files found to commit"
        fi

    - name: Upload logs as artifacts (backup)
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: bot-logs-${{ github.run_number }}
        path: |
          *.log
          *.json
          *.txt
          logs/
          feedback_log.txt
        retention-days: 7
